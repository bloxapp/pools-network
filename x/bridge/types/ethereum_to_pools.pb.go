// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bridge/v1beta/ethereum_to_pools.proto

package types

import (
	fmt "fmt"
	github_com_bloxapp_pools_network_shared_types "github.com/bloxapp/pools-network/shared/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ClaimType int32

const (
	ClaimType_Delegate       ClaimType = 0
	ClaimType_Undelegate     ClaimType = 1
	ClaimType_CreatePool     ClaimType = 2
	ClaimType_CreateOperator ClaimType = 3
)

var ClaimType_name = map[int32]string{
	0: "Delegate",
	1: "Undelegate",
	2: "CreatePool",
	3: "CreateOperator",
}

var ClaimType_value = map[string]int32{
	"Delegate":       0,
	"Undelegate":     1,
	"CreatePool":     2,
	"CreateOperator": 3,
}

func (x ClaimType) String() string {
	return proto.EnumName(ClaimType_name, int32(x))
}

func (ClaimType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1fc670358116c6e3, []int{0}
}

// ClaimData has a bunch of fields for different claims to use, all of them (except tx_hash and claim type) are optional
type ClaimData struct {
	TxHash             []byte                                                           `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	ClaimType          ClaimType                                                        `protobuf:"varint,2,opt,name=claimType,proto3,enum=bridge.v1beta1.ClaimType" json:"claimType,omitempty"`
	EthereumAddresses  []github_com_bloxapp_pools_network_shared_types.EthereumAddress  `protobuf:"bytes,3,rep,name=ethereum_addresses,json=ethereumAddresses,proto3,customtype=github.com/bloxapp/pools-network/shared/types.EthereumAddress" json:"ethereum_addresses,omitempty"`
	ConsensusAddresses []github_com_bloxapp_pools_network_shared_types.ConsensusAddress `protobuf:"bytes,4,rep,name=consensus_addresses,json=consensusAddresses,proto3,customtype=github.com/bloxapp/pools-network/shared/types.ConsensusAddress" json:"consensus_addresses,omitempty"`
	Values             []uint64                                                         `protobuf:"varint,5,rep,packed,name=values,proto3" json:"values,omitempty"`
}

func (m *ClaimData) Reset()         { *m = ClaimData{} }
func (m *ClaimData) String() string { return proto.CompactTextString(m) }
func (*ClaimData) ProtoMessage()    {}
func (*ClaimData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc670358116c6e3, []int{0}
}
func (m *ClaimData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimData.Merge(m, src)
}
func (m *ClaimData) XXX_Size() int {
	return m.Size()
}
func (m *ClaimData) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimData.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimData proto.InternalMessageInfo

func (m *ClaimData) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *ClaimData) GetClaimType() ClaimType {
	if m != nil {
		return m.ClaimType
	}
	return ClaimType_Delegate
}

func (m *ClaimData) GetValues() []uint64 {
	if m != nil {
		return m.Values
	}
	return nil
}

// MsgEthereumClaim is a container for events that happened on the ethereum blockchain.
// It's essentially an ethereum -> pools oracle
// The nonce is a monotonic id of the claim msg, it has to be sequential
// Due to eth1 probabilistic finality, each validator on the pools network will need to attest to all claims to make them be included in the state (2/3 vote).
type MsgEthereumClaim struct {
	Nonce            uint64                                                         `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	EthereumChainId  uint64                                                         `protobuf:"varint,2,opt,name=ethereum_chain_id,json=ethereumChainId,proto3" json:"ethereum_chain_id,omitempty"`
	ContractAddress  github_com_bloxapp_pools_network_shared_types.EthereumAddress  `protobuf:"bytes,3,opt,name=contract_address,json=contractAddress,proto3,customtype=github.com/bloxapp/pools-network/shared/types.EthereumAddress" json:"contract_address"`
	ConsensusAddress github_com_bloxapp_pools_network_shared_types.ConsensusAddress `protobuf:"bytes,4,opt,name=consensus_address,json=consensusAddress,proto3,customtype=github.com/bloxapp/pools-network/shared/types.ConsensusAddress" json:"consensus_address"`
	Data             []*ClaimData                                                   `protobuf:"bytes,5,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgEthereumClaim) Reset()         { *m = MsgEthereumClaim{} }
func (m *MsgEthereumClaim) String() string { return proto.CompactTextString(m) }
func (*MsgEthereumClaim) ProtoMessage()    {}
func (*MsgEthereumClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc670358116c6e3, []int{1}
}
func (m *MsgEthereumClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEthereumClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEthereumClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEthereumClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEthereumClaim.Merge(m, src)
}
func (m *MsgEthereumClaim) XXX_Size() int {
	return m.Size()
}
func (m *MsgEthereumClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEthereumClaim.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEthereumClaim proto.InternalMessageInfo

func (m *MsgEthereumClaim) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MsgEthereumClaim) GetEthereumChainId() uint64 {
	if m != nil {
		return m.EthereumChainId
	}
	return 0
}

func (m *MsgEthereumClaim) GetData() []*ClaimData {
	if m != nil {
		return m.Data
	}
	return nil
}

type EthereumBridgeContact struct {
	ContractAddress github_com_bloxapp_pools_network_shared_types.EthereumAddress `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3,customtype=github.com/bloxapp/pools-network/shared/types.EthereumAddress" json:"contract_address"`
	ChainId         uint64                                                        `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *EthereumBridgeContact) Reset()         { *m = EthereumBridgeContact{} }
func (m *EthereumBridgeContact) String() string { return proto.CompactTextString(m) }
func (*EthereumBridgeContact) ProtoMessage()    {}
func (*EthereumBridgeContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc670358116c6e3, []int{2}
}
func (m *EthereumBridgeContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthereumBridgeContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EthereumBridgeContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EthereumBridgeContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthereumBridgeContact.Merge(m, src)
}
func (m *EthereumBridgeContact) XXX_Size() int {
	return m.Size()
}
func (m *EthereumBridgeContact) XXX_DiscardUnknown() {
	xxx_messageInfo_EthereumBridgeContact.DiscardUnknown(m)
}

var xxx_messageInfo_EthereumBridgeContact proto.InternalMessageInfo

func (m *EthereumBridgeContact) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

// ClaimAttestation is a container for counting claim attestations
type ClaimAttestation struct {
	ClaimId          []byte                                                        `protobuf:"bytes,1,opt,name=claim_id,json=claimId,proto3" json:"claim_id,omitempty"`
	ContractAddress  github_com_bloxapp_pools_network_shared_types.EthereumAddress `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3,customtype=github.com/bloxapp/pools-network/shared/types.EthereumAddress" json:"contract_address"`
	Votes            map[string]bool                                               `protobuf:"bytes,3,rep,name=votes,proto3" json:"votes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AccumulatedPower uint64                                                        `protobuf:"varint,4,opt,name=accumulated_power,json=accumulatedPower,proto3" json:"accumulated_power,omitempty"`
	Finalized        bool                                                          `protobuf:"varint,5,opt,name=finalized,proto3" json:"finalized,omitempty"`
}

func (m *ClaimAttestation) Reset()         { *m = ClaimAttestation{} }
func (m *ClaimAttestation) String() string { return proto.CompactTextString(m) }
func (*ClaimAttestation) ProtoMessage()    {}
func (*ClaimAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc670358116c6e3, []int{3}
}
func (m *ClaimAttestation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimAttestation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimAttestation.Merge(m, src)
}
func (m *ClaimAttestation) XXX_Size() int {
	return m.Size()
}
func (m *ClaimAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimAttestation proto.InternalMessageInfo

func (m *ClaimAttestation) GetClaimId() []byte {
	if m != nil {
		return m.ClaimId
	}
	return nil
}

func (m *ClaimAttestation) GetVotes() map[string]bool {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (m *ClaimAttestation) GetAccumulatedPower() uint64 {
	if m != nil {
		return m.AccumulatedPower
	}
	return 0
}

func (m *ClaimAttestation) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

func init() {
	proto.RegisterEnum("bridge.v1beta1.ClaimType", ClaimType_name, ClaimType_value)
	proto.RegisterType((*ClaimData)(nil), "bridge.v1beta1.ClaimData")
	proto.RegisterType((*MsgEthereumClaim)(nil), "bridge.v1beta1.MsgEthereumClaim")
	proto.RegisterType((*EthereumBridgeContact)(nil), "bridge.v1beta1.EthereumBridgeContact")
	proto.RegisterType((*ClaimAttestation)(nil), "bridge.v1beta1.ClaimAttestation")
	proto.RegisterMapType((map[string]bool)(nil), "bridge.v1beta1.ClaimAttestation.VotesEntry")
}

func init() {
	proto.RegisterFile("bridge/v1beta/ethereum_to_pools.proto", fileDescriptor_1fc670358116c6e3)
}

var fileDescriptor_1fc670358116c6e3 = []byte{
	// 657 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xdf, 0x4a, 0xdc, 0x4e,
	0x14, 0xde, 0x64, 0xb3, 0xba, 0x7b, 0x94, 0x35, 0xce, 0xcf, 0x5f, 0x1b, 0xa5, 0xac, 0xcb, 0x42,
	0x61, 0x51, 0x4c, 0xd0, 0x5e, 0x54, 0x0a, 0x2d, 0xec, 0xae, 0x96, 0x7a, 0x21, 0x95, 0xd0, 0xf6,
	0xa2, 0x37, 0xcb, 0x6c, 0x72, 0xba, 0x09, 0x66, 0x33, 0x21, 0x33, 0xd1, 0xdd, 0x3e, 0x45, 0x1f,
	0xa2, 0x0f, 0xe3, 0xa5, 0x97, 0x45, 0x8a, 0x14, 0xbd, 0x28, 0xf4, 0x29, 0x4a, 0x26, 0x89, 0xff,
	0xaa, 0x94, 0x22, 0xde, 0xe5, 0x7c, 0xf3, 0xe5, 0x7c, 0x67, 0xbe, 0x33, 0xe7, 0xc0, 0xd3, 0x41,
	0xec, 0xbb, 0x43, 0xb4, 0x0e, 0xd6, 0x07, 0x28, 0xa8, 0x85, 0xc2, 0xc3, 0x18, 0x93, 0x51, 0x5f,
	0xb0, 0x7e, 0xc4, 0x58, 0xc0, 0xcd, 0x28, 0x66, 0x82, 0x91, 0x7a, 0x46, 0x33, 0x33, 0xda, 0xfa,
	0xd2, 0xc2, 0x90, 0x0d, 0x99, 0x3c, 0xb2, 0xd2, 0xaf, 0x8c, 0xd5, 0xfa, 0xae, 0x42, 0xad, 0x17,
	0x50, 0x7f, 0xb4, 0x45, 0x05, 0x25, 0x8f, 0x61, 0x5a, 0x8c, 0xfb, 0x1e, 0xe5, 0x9e, 0xa1, 0x34,
	0x95, 0xf6, 0xac, 0x3d, 0x25, 0xc6, 0x6f, 0x28, 0xf7, 0xc8, 0x73, 0xa8, 0x39, 0x29, 0xeb, 0xdd,
	0x24, 0x42, 0x43, 0x6d, 0x2a, 0xed, 0xfa, 0xc6, 0xa2, 0x79, 0x5d, 0xc0, 0xec, 0x15, 0x04, 0xfb,
	0x92, 0x4b, 0x22, 0x20, 0x17, 0x05, 0x52, 0xd7, 0x8d, 0x91, 0x73, 0xe4, 0x46, 0xb9, 0x59, 0x6e,
	0xcf, 0x76, 0x3b, 0x27, 0xa7, 0xcb, 0x2f, 0x87, 0xbe, 0xf0, 0x92, 0x81, 0xe9, 0xb0, 0x91, 0x35,
	0x08, 0xd8, 0x98, 0x46, 0x91, 0x25, 0x6f, 0xb1, 0x16, 0xa2, 0x38, 0x64, 0xf1, 0xbe, 0xc5, 0x3d,
	0x1a, 0xa3, 0x6b, 0x89, 0x49, 0x84, 0xdc, 0xdc, 0xce, 0x73, 0x75, 0xb2, 0x54, 0xf6, 0x3c, 0x5e,
	0x07, 0x90, 0x13, 0x0e, 0xff, 0x39, 0x2c, 0xe4, 0x18, 0xf2, 0x84, 0x5f, 0x91, 0xd4, 0xa4, 0x64,
	0xf7, 0xe4, 0x74, 0xf9, 0xd5, 0xbf, 0x49, 0xf6, 0x8a, 0x64, 0x85, 0x26, 0x71, 0x6e, 0x20, 0xc8,
	0xc9, 0x23, 0x98, 0x3a, 0xa0, 0x41, 0x82, 0xdc, 0xa8, 0x34, 0xcb, 0x6d, 0xcd, 0xce, 0xa3, 0xd6,
	0x2f, 0x15, 0xf4, 0x5d, 0x3e, 0x2c, 0xca, 0x96, 0x16, 0x91, 0x05, 0xa8, 0x84, 0x2c, 0x74, 0x50,
	0x7a, 0xac, 0xd9, 0x59, 0x40, 0x56, 0xe0, 0xe2, 0x32, 0x7d, 0xc7, 0xa3, 0x7e, 0xd8, 0xf7, 0x5d,
	0x69, 0xb5, 0x66, 0xcf, 0x15, 0x07, 0xbd, 0x14, 0xdf, 0x71, 0x49, 0x04, 0xba, 0xc3, 0x42, 0x11,
	0x53, 0x47, 0x14, 0x57, 0x34, 0xca, 0x69, 0xc3, 0xba, 0xdb, 0x47, 0xa7, 0xcb, 0xa5, 0xfb, 0xfb,
	0x3a, 0x57, 0xa4, 0xcf, 0x01, 0xc2, 0x61, 0xfe, 0x0f, 0x57, 0x0d, 0x4d, 0x4a, 0xbe, 0xce, 0x25,
	0xef, 0xeb, 0xab, 0x7e, 0xd3, 0x57, 0xb2, 0x06, 0x9a, 0x4b, 0x05, 0x95, 0x9e, 0xce, 0xdc, 0xf1,
	0xe0, 0xd2, 0x77, 0x6b, 0x4b, 0x5a, 0xeb, 0xab, 0x02, 0xff, 0x17, 0x17, 0xe9, 0x4a, 0x6a, 0x8f,
	0x85, 0x82, 0x3a, 0xe2, 0x56, 0xbf, 0x94, 0x07, 0xf5, 0x6b, 0x11, 0xaa, 0x37, 0x9a, 0x38, 0xed,
	0x64, 0xcd, 0x6b, 0xfd, 0x54, 0x41, 0x97, 0xa5, 0x77, 0x84, 0x40, 0x2e, 0xa8, 0xf0, 0x59, 0x28,
	0xf9, 0x29, 0x96, 0xf2, 0xb3, 0xd1, 0x9b, 0x96, 0xf1, 0x1d, 0xcd, 0x56, 0x1f, 0xb4, 0xf8, 0x0e,
	0x54, 0x0e, 0x98, 0xc8, 0xe7, 0x74, 0x66, 0x63, 0xf5, 0x56, 0xe3, 0xaf, 0x54, 0x6f, 0x7e, 0x48,
	0xd9, 0xdb, 0xa1, 0x88, 0x27, 0x76, 0xf6, 0x27, 0x59, 0x85, 0x79, 0xea, 0x38, 0xc9, 0x28, 0x09,
	0xa8, 0x40, 0xb7, 0x1f, 0xb1, 0x43, 0x8c, 0xe5, 0x7b, 0xd1, 0x6c, 0xfd, 0xca, 0xc1, 0x5e, 0x8a,
	0x93, 0x27, 0x50, 0xfb, 0xe4, 0x87, 0x34, 0xf0, 0x3f, 0xa3, 0x6b, 0x54, 0x9a, 0x4a, 0xbb, 0x6a,
	0x5f, 0x02, 0x4b, 0x9b, 0x00, 0x97, 0xf9, 0x89, 0x0e, 0xe5, 0x7d, 0x9c, 0x48, 0x8f, 0x6a, 0x76,
	0xfa, 0x99, 0x8e, 0x93, 0x9c, 0x36, 0x69, 0x4a, 0xd5, 0xce, 0x82, 0x17, 0xea, 0xa6, 0xb2, 0xb2,
	0x9b, 0xef, 0x36, 0xb9, 0x89, 0x66, 0xa1, 0xba, 0x85, 0x01, 0x0e, 0xa9, 0x40, 0xbd, 0x44, 0xea,
	0x00, 0xef, 0x43, 0xb7, 0x88, 0x95, 0x34, 0xee, 0xc5, 0x48, 0x05, 0xee, 0x31, 0x16, 0xe8, 0x2a,
	0x21, 0x50, 0xcf, 0xe2, 0xb7, 0x11, 0xc6, 0x54, 0xb0, 0x58, 0x2f, 0x77, 0x77, 0x8e, 0xce, 0x1a,
	0xca, 0xf1, 0x59, 0x43, 0xf9, 0x71, 0xd6, 0x50, 0xbe, 0x9c, 0x37, 0x4a, 0xc7, 0xe7, 0x8d, 0xd2,
	0xb7, 0xf3, 0x46, 0xe9, 0xa3, 0xf5, 0xd7, 0x06, 0x8c, 0xad, 0x7c, 0x6b, 0xcb, 0x16, 0x0c, 0xa6,
	0xe4, 0xf6, 0x7d, 0xf6, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xea, 0x59, 0xfc, 0x0f, 0xcc, 0x05, 0x00,
	0x00,
}

func (m *ClaimData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA2 := make([]byte, len(m.Values)*10)
		var j1 int
		for _, num := range m.Values {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintEthereumToPools(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConsensusAddresses) > 0 {
		for iNdEx := len(m.ConsensusAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.ConsensusAddresses[iNdEx].Size()
				i -= size
				if _, err := m.ConsensusAddresses[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EthereumAddresses) > 0 {
		for iNdEx := len(m.EthereumAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.EthereumAddresses[iNdEx].Size()
				i -= size
				if _, err := m.EthereumAddresses[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ClaimType != 0 {
		i = encodeVarintEthereumToPools(dAtA, i, uint64(m.ClaimType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintEthereumToPools(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEthereumClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEthereumClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEthereumClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size := m.ConsensusAddress.Size()
		i -= size
		if _, err := m.ConsensusAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ContractAddress.Size()
		i -= size
		if _, err := m.ContractAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EthereumChainId != 0 {
		i = encodeVarintEthereumToPools(dAtA, i, uint64(m.EthereumChainId))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintEthereumToPools(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EthereumBridgeContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthereumBridgeContact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthereumBridgeContact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChainId != 0 {
		i = encodeVarintEthereumToPools(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ContractAddress.Size()
		i -= size
		if _, err := m.ContractAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClaimAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimAttestation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimAttestation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Finalized {
		i--
		if m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AccumulatedPower != 0 {
		i = encodeVarintEthereumToPools(dAtA, i, uint64(m.AccumulatedPower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Votes) > 0 {
		for k := range m.Votes {
			v := m.Votes[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEthereumToPools(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEthereumToPools(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.ContractAddress.Size()
		i -= size
		if _, err := m.ContractAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEthereumToPools(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ClaimId) > 0 {
		i -= len(m.ClaimId)
		copy(dAtA[i:], m.ClaimId)
		i = encodeVarintEthereumToPools(dAtA, i, uint64(len(m.ClaimId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEthereumToPools(dAtA []byte, offset int, v uint64) int {
	offset -= sovEthereumToPools(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClaimData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovEthereumToPools(uint64(l))
	}
	if m.ClaimType != 0 {
		n += 1 + sovEthereumToPools(uint64(m.ClaimType))
	}
	if len(m.EthereumAddresses) > 0 {
		for _, e := range m.EthereumAddresses {
			l = e.Size()
			n += 1 + l + sovEthereumToPools(uint64(l))
		}
	}
	if len(m.ConsensusAddresses) > 0 {
		for _, e := range m.ConsensusAddresses {
			l = e.Size()
			n += 1 + l + sovEthereumToPools(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovEthereumToPools(uint64(e))
		}
		n += 1 + sovEthereumToPools(uint64(l)) + l
	}
	return n
}

func (m *MsgEthereumClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovEthereumToPools(uint64(m.Nonce))
	}
	if m.EthereumChainId != 0 {
		n += 1 + sovEthereumToPools(uint64(m.EthereumChainId))
	}
	l = m.ContractAddress.Size()
	n += 1 + l + sovEthereumToPools(uint64(l))
	l = m.ConsensusAddress.Size()
	n += 1 + l + sovEthereumToPools(uint64(l))
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovEthereumToPools(uint64(l))
		}
	}
	return n
}

func (m *EthereumBridgeContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ContractAddress.Size()
	n += 1 + l + sovEthereumToPools(uint64(l))
	if m.ChainId != 0 {
		n += 1 + sovEthereumToPools(uint64(m.ChainId))
	}
	return n
}

func (m *ClaimAttestation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClaimId)
	if l > 0 {
		n += 1 + l + sovEthereumToPools(uint64(l))
	}
	l = m.ContractAddress.Size()
	n += 1 + l + sovEthereumToPools(uint64(l))
	if len(m.Votes) > 0 {
		for k, v := range m.Votes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEthereumToPools(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovEthereumToPools(uint64(mapEntrySize))
		}
	}
	if m.AccumulatedPower != 0 {
		n += 1 + sovEthereumToPools(uint64(m.AccumulatedPower))
	}
	if m.Finalized {
		n += 2
	}
	return n
}

func sovEthereumToPools(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEthereumToPools(x uint64) (n int) {
	return sovEthereumToPools(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClaimData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereumToPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimType", wireType)
			}
			m.ClaimType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimType |= ClaimType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthereumAddresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_bloxapp_pools_network_shared_types.EthereumAddress
			m.EthereumAddresses = append(m.EthereumAddresses, v)
			if err := m.EthereumAddresses[len(m.EthereumAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusAddresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_bloxapp_pools_network_shared_types.ConsensusAddress
			m.ConsensusAddresses = append(m.ConsensusAddresses, v)
			if err := m.ConsensusAddresses[len(m.ConsensusAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEthereumToPools
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEthereumToPools
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEthereumToPools
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthEthereumToPools
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEthereumToPools
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereumToPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEthereumClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereumToPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEthereumClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEthereumClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthereumChainId", wireType)
			}
			m.EthereumChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthereumChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConsensusAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ClaimData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereumToPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthereumBridgeContact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereumToPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthereumBridgeContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthereumBridgeContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereumToPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereumToPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimId = append(m.ClaimId[:0], dAtA[iNdEx:postIndex]...)
			if m.ClaimId == nil {
				m.ClaimId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Votes == nil {
				m.Votes = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEthereumToPools
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEthereumToPools
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEthereumToPools
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEthereumToPools
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEthereumToPools
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEthereumToPools(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEthereumToPools
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Votes[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedPower", wireType)
			}
			m.AccumulatedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumulatedPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEthereumToPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereumToPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEthereumToPools(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEthereumToPools
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEthereumToPools
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEthereumToPools
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEthereumToPools
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEthereumToPools
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEthereumToPools        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEthereumToPools          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEthereumToPools = fmt.Errorf("proto: unexpected end of group")
)
